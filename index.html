<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - loaders - MMD loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #fff;
			color: #444;
		}

		a {
			color: #08f;
		}
	</style>
</head>

<body>
	<div id="info"></div>

	<script src="js/libs/ammo.wasm.js"></script>
	<script src="scoreoutputer.min.js"></script>
	<script>
		// 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
		// 以下面範例，檔名就為 "109598105(總分: 6).csv"
		var so = new ScoreOutputer("110598009");
		so.installCSS(function () {
			// 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
			// installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

			//加入項目，分數，完成狀況
			//第一個參數為 項目名稱
			//第2個參數為 項目分數
			//第3個參數為 完成狀況，有完成 true/未完成 false
			//有幾個項目就呼叫幾個 addChild
			//addChild 要比 renderModal 先呼叫
			so.addChild("繪製出 5 個畫面", 1, true);
			so.addChild("回答問題", 1, false);
			so.addChild("可按鍵選擇上 / 下一隻角色", 1, false);
			so.addChild("讀取作業 2 儲存的座標點在眼睛上繪製出分割線", 1, false);
			so.addChild("可選擇當下控制哪個虹膜", 1, false);
			so.addChild("按滑鼠左鍵控制虹膜移動，右鍵停止", 2, false);
			so.addChild("複製參數至對應目標參數", 2, false);
			so.addChild("可儲存虹膜轉動角度", 1, false);

			//產生自評表，參數如下所示
			so.renderModal(
				//1. 自評表插入位置 (預設 document.body)
				document.body,
				//2. 自評表背景 (預設紅色)
				'rgba(100,45,58,1)',
				//3. 自評表文字顏色 (預設白色)
				'white',
				//4. 自評表文字大小 (預設 14pt)
				'15pt',
				//5. 自評表 checkbox 文字大小 (預設多少忘了)
				'15px',
				//6. 自評表標題 (預設 "自我評分表")
				dialogTitle = "自我評分表"
			);

			//設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
			so.installDownloadBtn();

			//產生 "開啟自評表按鈕"
			so.renderBtn(
				//自評表按鈕插入位置
				document.querySelector("#info"),
				//自評表按鈕文字
				"開啟自評表"
			);
		});
	</script>
	<script type="module">

		import * as THREE from './build/three.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { OutlineEffect } from './jsm/effects/OutlineEffect.js';
		import { MMDLoader } from './jsm/loaders/MMDLoader.js';
		import { MMDAnimationHelper } from './jsm/animation/MMDAnimationHelper.js';

		let scene, renderer, effect;
		let mesh, helper;
		let SCREEN_WIDTH = window.innerWidth;
		let SCREEN_HEIGHT = window.innerHeight;
		let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
		let frustumSize = 30;
		let camera, camera1, camera2, camera3, camera4;
		let leftEye, rightEye, leftEyeLines, rightEyeLines;
		let bothEyes = [];
		let modelSelected = 0, indexOfCameraSegments = 1, moving = false;
		let eyes = [
			new THREE.Vector2(0,0),
			new THREE.Vector2(0,0),
			new THREE.Vector2(0,0),
			new THREE.Vector2(0,0),
			new THREE.Vector2(0,0),
			new THREE.Vector2(0,0.1),
			new THREE.Vector2(0,0.2),
			new THREE.Vector2(0,-0.2),
			new THREE.Vector2(0,-0.1),
		];
		const mousePosition = new THREE.Vector3(0,0,0);
		const modelFiles = [];
		Ammo().then(function (AmmoLib) {

			Ammo = AmmoLib;

			init();
			animate();

		});

		function init() {

			const container = document.createElement('div');
			document.body.appendChild(container);
			camera = new THREE.OrthographicCamera(0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 0.1, 1000);
			camera1 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / - 2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / - 2, 0.1, 1000);
			camera2 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / - 2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / - 2, 0.1, 1000);
			camera3 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / - 2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / - 2, 0.1, 1000);
			camera4 = new THREE.OrthographicCamera(0.25 * frustumSize * aspect / - 2, 0.25 * frustumSize * aspect / 2, 0.5 * frustumSize / 2, 0.5 * frustumSize / - 2, 0.1, 1000);
			camera.position.z = 30;
			camera1.position.z = 30;
			camera2.position.z = 30;
			camera3.position.z = 30;
			camera4.position.z = 30;
			camera.position.y = 8.2;
			camera1.position.y = 8.1;
			camera2.position.y = 8.1;
			camera3.position.y = 8.1;
			camera4.position.y = 8.1;
			camera.position.x = -0.5;
			camera.zoom = 32;
			camera1.zoom = 9;
			camera2.zoom = 9;
			camera3.zoom = 9;
			camera4.zoom = 9;
			camera.updateProjectionMatrix();
			camera1.updateProjectionMatrix();
			camera2.updateProjectionMatrix();
			camera3.updateProjectionMatrix();
			camera4.updateProjectionMatrix();

			// scene
			scene = new THREE.Scene();
			const ambient = new THREE.AmbientLight(0x666666);
			scene.add(ambient);

			const directionalLight = new THREE.DirectionalLight(0x887766);
			directionalLight.position.set(- 1, 1, 1).normalize();
			scene.add(directionalLight);

			// renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);
			renderer.autoClear = false;
			effect = new OutlineEffect(renderer);

			// load 模型檔
			loadModel();

			// 活動宣告
			var body = document.body;
			window.addEventListener( 'mousedown', onMouseDown );
			body.addEventListener( 'keydown', onKeyDown );
			window.addEventListener('resize', onWindowResize);
			
			drawLine();
		}

		function loadModel() {
			// model
			function onProgress(xhr) {

				if (xhr.lengthComputable) {

					const percentComplete = xhr.loaded / xhr.total * 100;
					console.log(Math.round(percentComplete, 2) + '% downloaded');

				}

			}

			const modelFile = 'models/mmd/kizunaai/kizunaai.pmx';

			helper = new MMDAnimationHelper();

			const loader = new MMDLoader();
			//modelFiles[modelSelected]
			loader.load(modelFile, function (object) {

				mesh = object;
				mesh.name = 'model' + modelSelected;
				mesh.position.y = - 10;
				const bones = mesh.skeleton.bones;
				//console.log(bones);
				const boneNameDictionary = {};
				for ( let i = 0, il = bones.length; i < il; i ++ ) {
					//boneNameDictionary[ bones[ i ].name ] = i;
					boneNameDictionary[ bones[ i ].name ] = i;
					//if( bones[ i ].name === '左目' || bones[ i ].name === '右目' )
						//console.log(bones[ i ].name);
				}
				console.log(bones[ boneNameDictionary[ '左目' ] ]);
				console.log(bones[ boneNameDictionary[ '右目' ] ]);
				leftEye = bones[ boneNameDictionary[ '左目' ] ];
				rightEye = bones[ boneNameDictionary[ '右目' ] ];
				bothEyes.push(leftEye);
				bothEyes.push(rightEye);
				scene.add(mesh);

			}, onProgress, null);
		}

		function onWindowResize() {

			SCREEN_WIDTH = window.innerWidth;
			SCREEN_HEIGHT = window.innerHeight;
			aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

			effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			camera.left = 0.5 * frustumSize * aspect / - 2;
			camera.right = 0.5 * frustumSize * aspect / 2;
			camera.top = frustumSize / 2;
			camera.bottom = - frustumSize / 2;
			camera.updateProjectionMatrix();

			camera1.left = 0.25 * frustumSize * aspect / - 2;
			camera1.right = 0.25 * frustumSize * aspect / 2;
			camera1.top = 0.5 * frustumSize / 2;
			camera1.bottom = - 0.5 * frustumSize / 2;
			camera1.updateProjectionMatrix();

			camera2.left = 0.25 * frustumSize * aspect / - 2;
			camera2.right = 0.25 * frustumSize * aspect / 2;
			camera2.top = 0.5 * frustumSize / 2;
			camera2.bottom = - 0.5 * frustumSize / 2;
			camera2.updateProjectionMatrix();

			camera3.left = 0.25 * frustumSize * aspect / - 2;
			camera3.right = 0.25 * frustumSize * aspect / 2;
			camera3.top = 0.5 * frustumSize / 2;
			camera3.bottom = - 0.5 * frustumSize / 2;
			camera3.updateProjectionMatrix();

			camera4.left = 0.25 * frustumSize * aspect / - 2;
			camera4.right = 0.25 * frustumSize * aspect / 2;
			camera4.top = 0.5 * frustumSize / 2;
			camera4.bottom = - 0.5 * frustumSize / 2;
			camera4.updateProjectionMatrix();
		}

		function onKeyDown( event ) {

			const keyCode = event.keyCode;
			
			// 設定 1~2 keyCode 
			if ( keyCode === 49 || keyCode === 97 ) {

				indexOfCameraSegments--;
				if( indexOfCameraSegments < 1 ) {
					indexOfCameraSegments = 1;
					return;
				}
				if( camera.position.x > 0 )
					camera.position.x = -0.5;
				else
					camera.position.x = 0.5;
				camera.updateProjectionMatrix();
				return false;

			}
			if ( keyCode === 50 || keyCode === 98 ) {

				indexOfCameraSegments++;
				if( indexOfCameraSegments > 8 ) {
					indexOfCameraSegments = 8;
					return;
				}
				if( camera.position.x > 0 )
					camera.position.x = -0.5;
				else
					camera.position.x = 0.5;
				camera.updateProjectionMatrix();
				return false;

			}

			// 按 A 向左查看角色
			if ( keyCode === 65 ) {

				var selectedObject = scene.getObjectByName("model" + modelSelected);
				// scene.remove(selectedObject);
				// for(let obj of objectOfLines) {
				// 	scene.remove(obj);
				// }

				modelSelected--;

				if( modelSelected < 0 )
					modelSelected += 3;

				loadModel();
				return false;

			}

			// 按 D 向右查看角色
			if ( keyCode === 68 ) {

				var selectedObject = scene.getObjectByName("model" + modelSelected);
				scene.remove(selectedObject);
				// for(let obj of objectOfLines) {
				// 	scene.remove(obj);
				// }

				modelSelected++;

				if( modelSelected > 2 )
					modelSelected = 0;

				loadModel();
				return false;

			}
		}

		function onMouseMove( event ) {

				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components
				const { left, top, width, height } = event.currentTarget.getBoundingClientRect();
				mousePosition.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					-( event.clientY / window.innerHeight ) * 2 + 1,
					(camera.near + camera.far) / (camera.near - camera.far),
				);
				//mousePosition.unproject(camera);

		}

		let leftEyeFramePosition = [4];
		function onMouseDown ( event ) {

			event.preventDefault();
			if( event.button === 0 ) {
				// 按滑鼠左鍵控制虹膜移動，右鍵停止
				//if(indexOfLines >= 0) {
					//alert(indexOfLines+', '+leftEyeFramePosition[0].x+', '+leftEyeFramePosition[0].y);
					//leftEyeFramePosition[indexOfLines] = pointer;
				//}
				//indexOfLines = -1;
				moving = true;
				document.body.addEventListener( 'mousemove', onMouseMove );

			}
			else if( event.button === 1 ) {
				// 按滑鼠右鍵停止虹膜移動
				moving = false;
				document.body.removeEventListener( 'mousemove', onMouseMove );
			}

		}

		var line;
		function drawLine() {

			// 當每案一次按鍵都會重畫，因此要先移除。
			// if(scene.getObjectByName("line" + indexOfLines) != null) {
			// 	var selectedObject = scene.getObjectByName("line" + indexOfLines);
			// 	scene.remove(selectedObject);
			// }

			const points = [];
			let material, indexOfLines=0;
			if(indexOfLines % 2 == 0) {
				points.push( new THREE.Vector3( -0.42, 0, 20 ) );
				points.push( new THREE.Vector3( 0.42, 0, 20 ) );
				material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			}
			else {
				points.push( new THREE.Vector3( 0, -0.82, 20 ) );
				points.push( new THREE.Vector3( 0, 0.82, 20 ) );
				material = new THREE.LineBasicMaterial( { color: 0xff0080 } );
			}

			const geometry = new THREE.BufferGeometry().setFromPoints( points );

			line = new THREE.Line( geometry, material );
			scene.add( line );
			line.name = "line" + indexOfLines;
			line.position.x = -0.46097991807610905;
			line.position.y = 8.402409374485611;
			//objectOfLines.push( line );

		}

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			effect.clear();
			//drawLine();
			if(rightEye == null)
				return;
			// 滑鼠移動時，讓 camera 只 focus 在一種變量。不然會混和其他設定。
			rightEye.rotation.copy(new THREE.Euler( 0, 0, 0, 'XYZ' ));
			leftEye.rotation.copy(new THREE.Euler( 0, 0, 0, 'XYZ' ));
			if(moving) {
				if(indexOfCameraSegments == 1) {
					rightEye.rotation.x = eyes[1].x = -mousePosition.y;
				}
				else if(indexOfCameraSegments == 2) {
					leftEye.rotation.x = eyes[2].x = -mousePosition.y;
				}
				else if(indexOfCameraSegments == 3) {
					rightEye.rotation.x = eyes[3].x = -mousePosition.y;
				}
				else if(indexOfCameraSegments == 4) {
					leftEye.rotation.x = eyes[4].x = -mousePosition.y;
				}
				else if(indexOfCameraSegments == 5) {
					rightEye.rotation.y = eyes[5].y = mousePosition.x;
				}
				else if(indexOfCameraSegments == 6) {
					leftEye.rotation.y = eyes[6].y = mousePosition.x;
				}
				else if(indexOfCameraSegments == 7) {
					rightEye.rotation.y = eyes[7].y = mousePosition.x;
				}
				else if(indexOfCameraSegments == 8) {
					leftEye.rotation.y = eyes[8].y = mousePosition.x;
				}
			}
			else {
				eyes[0] = eyes[indexOfCameraSegments];
				// index 為奇數是右眼、偶數是左眼。先分哪幾顆眼睛改 rotation 的 x or y 
				// 前4顆眼睛改 x(camera1、cemera2)；後4顆眼睛改 y(camera3、cemera4)。
				// bothEyes = {rightEye, leftEye}。
				if(indexOfCameraSegments <=4) {
					bothEyes[indexOfCameraSegments % 2].rotation.x = eyes[0].x;
					bothEyes[indexOfCameraSegments % 2].rotation.y = 0;
				}
				else {
					bothEyes[indexOfCameraSegments % 2].rotation.y = eyes[0].y;
					bothEyes[indexOfCameraSegments % 2].rotation.x = 0;
				}
			}
			//if(moving)
				//console.log(mousePosition);
			effect.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
			effect.render(scene, camera);

			if( indexOfCameraSegments != 1 || indexOfCameraSegments != 2) {
				//這裡 camera1 中的左右眼不能隨滑鼠移動
				rightEye.rotation.x=eyes[1].x;
				rightEye.rotation.y=eyes[1].y;
				leftEye.rotation.x=eyes[2].x;
				leftEye.rotation.y=eyes[2].y;
			}
			effect.setViewport(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
			effect.render(scene, camera1);

			// if( indexOfCameraSegments != 3 || indexOfCameraSegments != 4) {
			// 	//這裡 camera2 中的左右眼不能隨滑鼠移動
			// 	//讀取之前的 iris rotation
			// 	rightEye.rotation.x=eyes[3].x;
			// 	leftEye.rotation.x=eyes[4].x;
			// }
			rightEye.rotation.x=eyes[3].x;
			rightEye.rotation.y=eyes[3].y;
			leftEye.rotation.x=eyes[4].x;
			leftEye.rotation.y=eyes[4].y;
			effect.setViewport(SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
			effect.render(scene, camera2);

			// if( indexOfCameraSegments != 5 || indexOfCameraSegments != 6) {
			// 	//這裡 camera3 中的左右眼不能隨滑鼠移動
			// 	//讀取之前的 iris rotation
			// 	rightEye.rotation.y = eyes[5].y;
			// 	leftEye.rotation.y = eyes[6].y;
			// }
			rightEye.rotation.x=eyes[5].x;
			rightEye.rotation.y=eyes[5].y;
			leftEye.rotation.x=eyes[6].x;
			leftEye.rotation.y=eyes[6].y;
			effect.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
			effect.render(scene, camera3);

			rightEye.rotation.x=eyes[7].x;
			rightEye.rotation.y=eyes[7].y;
			leftEye.rotation.x=eyes[8].x;
			leftEye.rotation.y=eyes[8].y;
			effect.setViewport(SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4, 0, SCREEN_WIDTH / 4, SCREEN_HEIGHT / 2);
			effect.render(scene, camera4);
		}
	</script>

</body>

</html>